{-# OPTIONS --safe --without-K #-}

open import Level

module Functions.Raw where

import Function as F
open import Data.Product as √ó using (_,_; proj‚ÇÅ; proj‚ÇÇ; <_,_>)
import Data.Bool as B

open import Categorical.Raw
open import Categorical.Equiv

open import Functions.Type public

module ‚Üí-raw-instances where

  instance

    category : Category Function
    category = record { id = F.id ; _‚àò_ = F._‚àò‚Ä≤_ }

    cartesian : Cartesian Function
    cartesian = record { exl = proj‚ÇÅ ; exr = proj‚ÇÇ ; _‚ñµ_ = <_,_> }

    cartesianClosed : CartesianClosed Function
    cartesianClosed = record { curry = √ó.curry ; apply = √ó.uncurry id }

    logic : Logic Function
    logic = record
              { false = Œª tt ‚Üí ùïó
              ; true  = Œª tt ‚Üí ùï•
              ; not   = B.not
              ; ‚àß     = uncurry B._‚àß_
              ; ‚à®     = uncurry B._‚à®_
              ; xor   = uncurry B._xor_
              ; cond  = Œª (c , e , t) ‚Üí B.if c then t else e
              }

    open import Relation.Binary.PropositionalEquality as ‚â° using (_‚â°_; _‚âó_)

    equivalent : Equivalent 0‚Ñì Function
    equivalent = record
      { _‚âà_ = _‚âó_
      ; equiv = record
          { refl  = Œª _ ‚Üí ‚â°.refl
          ; sym   = Œª f‚àºg x ‚Üí ‚â°.sym (f‚àºg x)
          ; trans = Œª f‚àºg g‚àºh x ‚Üí ‚â°.trans (f‚àºg x) (g‚àºh x)
          }
      }
